// This program is based heavily on the rp-l2tp package,
// and carries over that package's GPL v2 licensing.
//
// TiVo NOTES:
//
// It was necessary to have an L2TP client (LAC) that can communicate
// with the L2TP LNS at DirecTv.
//
// Trying to use rp-l2tp (which supports both LNS, and LAC behaviors) in
// its native form was cumbersome since it wants to run as a server,
// and then be told what to do by sending it commands over a socket.
// Instead, what we really wanted was a program that could be launched
// as a LAC when it was necessary, and could be told what to do entirely
// from the command line.
// 
// Instead of writing something from scratch, it was faster to modify
// rp-l2tp.

#include	"includes.h"

static l2tp_peer
	peer;						// the peer we want to connect to
static char
	interfaceName[IFNAMSIZ];	// name of the interface to bind to
static bool
	timeToExit;					// set true if it is time to quit

// make tokens for each of the command line options
enum
{
	OPT_HELP=1,
	OPT_DEBUG,
	OPT_COMMAND,
	OPT_INTERFACE,
	OPT_PEER,
	OPT_PORT,
	OPT_SECRET,
};

// define the command line options
static const struct option
	programOptions[]=
	{
		{"help",		no_argument,		NULL,OPT_HELP},
		{"debug",		required_argument,	NULL,OPT_DEBUG},
		{"command",		required_argument,	NULL,OPT_COMMAND},
		{"interface",	required_argument,	NULL,OPT_INTERFACE},
		{"peer",		required_argument,	NULL,OPT_PEER},
		{"port",		required_argument,	NULL,OPT_PORT},
		{"secret",		required_argument,	NULL,OPT_SECRET},
		{NULL,			0,					NULL,0},
	};

static void Usage(char *programName)
{
	fprintf(stderr,"Usage: %s [options]\n",programName);
	fprintf(stderr,"Options:\n");
	fprintf(stderr,"-help            Print usage\n");
	fprintf(stderr,"-debug level     Set debugging to 'level'\n");
	fprintf(stderr,"-command string  Client command to run in the tunnel\n");
	fprintf(stderr,"-interface name  Interface name to bind to (ANY if unspecified)\n");
	fprintf(stderr,"-peer name       Name or IP of LNS to connect to\n");
	fprintf(stderr,"-port number     Port number to connect to\n");
	fprintf(stderr,"-secret string   Secret to use during authentication\n");
	fprintf(stderr,"\n");
	fprintf(stderr,"This program is licensed under the terms of\n");
	fprintf(stderr,"the GNU General Public License, Version 2.\n");
}

static bool ProcessCommandLine(int argc,char *argv[])
// Process the command line. Use the information obtained to modify the globals
// which tell what operations to perform.
// If the command line is not complete, or is incorrect, then complain and
// return false. Otherwise return true.
{
	int
		option;
	int
		optionIndex;
	bool
		fail;
	struct hostent
		*he;
	bool
		hadCommand;
	bool
		hadPeer;

	fail=false;
	optionIndex=0;			// begin processing at the start
	hadCommand=false;
	hadPeer=false;
	peer.addr.sin_port=htons(1701);

	// run through all the options
	while(!fail&&(option=getopt_long_only(argc,argv,"",programOptions,&optionIndex))&&(option>=0))
	{
		switch(option)
		{

			case OPT_HELP:
				Usage(argv[0]);
				fail=true;				// when help is given, abort execution
				break;
			case OPT_DEBUG:
				l2tp_debug_set_bitmask(strtoul(optarg,NULL,0));
				break;
			case OPT_COMMAND:
				set_ppp_session_command(optarg);
				hadCommand=true;
				break;
			case OPT_INTERFACE:
				strncpy(interfaceName,optarg,sizeof(interfaceName));
				interfaceName[sizeof(interfaceName)-1]='\0';
				break;
			case OPT_PEER:
				he=gethostbyname(optarg);
				if(he)
				{
					memcpy(&peer.addr.sin_addr,he->h_addr,sizeof(peer.addr.sin_addr));
					hadPeer=true;
				}
				else
				{
					fprintf(stderr,"%s: cannot resolve hostname '%s'\n",argv[0],optarg);
					fail=true;
				}
				break;
			case OPT_PORT:
				peer.addr.sin_port=htons(strtoul(optarg,NULL,0));
				break;
			case OPT_SECRET:
			    strncpy(peer.secret,optarg,MAX_SECRET_LEN);
			    peer.secret[MAX_SECRET_LEN-1] = 0;
			    peer.secret_len=strlen(peer.secret);
				break;

			default:
				// unrecognized option complaint already generated by "getopt_long_only"
				fprintf(stderr,"\n");	// just kick out another CRLF, and report usage info
				Usage(argv[0]);
				fail=true;
				break;
		}
	}

	if(!fail)	// make sure no errors occurred above
	{
		if(optind<argc)
		{
			fprintf(stderr,"%s: extraneous command line data '%s'\n",argv[0],argv[optind]);
			fprintf(stderr,"\n");	// just kick out another CRLF, and report usage info
			Usage(argv[0]);
			fail=true;
		}
		else if(!hadPeer)
		{
			fprintf(stderr,"%s: Peer must be specified\n",argv[0]);
			fail=true;
		}
		else if(!hadCommand)
		{
			fprintf(stderr,"%s: Command must be specified\n",argv[0]);
			fail=true;
		}
	}

	return(!fail);
}

void TimeToExit()
// Call this when it's time to stop running (after a signal, or after a tunnel
// closes down).
{
	timeToExit=true;
}

static void InterruptHandler(int signal)
// Called by the event handler after an interrupt or termination signal
// has been caught.
// Tells us it is time to quit.
// Tunnels will clean themselves up at exit.
{
	TimeToExit();
}

int main(int argc,char *argv[])
{
	EventSelector
		*es;
	l2tp_session
		*session;
	bool
		result;

	memset(&peer,0,sizeof(peer));
	peer.addr.sin_family=AF_INET;
	interfaceName[0]='\0';

	result=0;
	if(ProcessCommandLine(argc,argv))
	{
		if((es=Event_CreateSelector()))
		{
			timeToExit=false;
			Event_HandleSignal(es,SIGINT,InterruptHandler);
			Event_HandleSignal(es,SIGTERM,InterruptHandler);

			if(l2tp_network_init(es,interfaceName[0]?interfaceName:NULL)>=0)
			{
				l2tp_random_init();
				l2tp_tunnel_init(es);
				session=l2tp_session_call_lns(&peer,"no number",es,NULL);	// create new session in new tunnel

				while(!timeToExit&&!result)
				{
					if(Event_HandleEvent(es)<0)
					{
						fprintf(stderr,"Event_HandleEvent failed\n");
						result=EXIT_FAILURE;
					}
				}
				l2tp_cleanup();												// cleanup all tunnels that are still open, wait for them to close

				l2tp_network_uninit(es);
			}

			Event_DestroySelector(es);
		}
		else
		{
			fprintf(stderr,"Failed to Event_CreateSelector\n");
			result=EXIT_FAILURE;
		}
	}
	return(result);
}
