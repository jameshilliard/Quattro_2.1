#
# General architecture dependent options
#

config OPROFILE
	tristate "OProfile system profiling without tracing"
	depends on PROFILING
	depends on HAVE_OPROFILE
	select RING_BUFFER
	help
	  OProfile is a profiling system capable of profiling the
	  whole system, include the kernel, kernel modules, libraries,
	  and applications. This simple version provides minimal
	  support for creating a profile using an interval event counter
	  to initiate the storing of the data. 

	  If unsure, say N.

config OPROFILE_DEBUG
	bool "OProfile system profiling debug printing"
	default n
	depends on OPROFILE
	help
	  OProfile is a profiling system debug output. The debug level is currently
	  one (on or off). This provides initialization, startup, and shutdown
	  event information. No information is available on a "per-sample" basis. 

	  If unsure, say N.

config OPROFILE_OVERFLOW_HANDLER
	bool "OProfile system profiling overflow handler(EXPERIMENTAL)"
	default y
	depends on OPROFILE
	help
	  OProfile is a profiling system is configured to call the performance
	  counter interrupt handler for every "timer" interrupt, however, when
	  this option is used, the performance counters are configured not to
	  generate an interrupt when an overflow occurs. This handler is still
	  called and the overflow conditions are handled but the handler never
	  return that is was handled. The performance counters are only checked
	  when a timer interrupt is dispatched and does not pre-empt the timer
	  interrupt handler (allows for simultaneous timer and performance
	  counter evenet).

	  If unsure, say Y. (TiVo specific)

config OPROFILE_TRACING
	bool "OProfile system profiling with tracing support(EXPERIMENTAL)"
	default n
	depends on OPROFILE && TRACING_SUPPORT
	select TRACING
	help
	  OProfile is a profiling system capable of profiling the
	  whole system, include the kernel, kernel modules, libraries,
	  and applications. This feature extends the functionality for
	  storing extended profiling information with stack tracing.
	  NOTE: This feature will add additional tracing functionality
	  that will increase the overhead required for accumulating the
	  profile information. 

	  If unsure, say N.

config OPROFILE_IBS
	bool "OProfile AMD IBS support (EXPERIMENTAL)"
	default n
	depends on OPROFILE && SMP && X86
	help
          Instruction-Based Sampling (IBS) is a new profiling
          technique that provides rich, precise program performance
          information. IBS is introduced by AMD Family10h processors
          (AMD Opteron Quad-Core processor "Barcelona") to overcome
          the limitations of conventional performance counter
          sampling.

	  If unsure, say N.

config HAVE_OPROFILE
	bool

config KPROBES
	bool "Kprobes"
	depends on KALLSYMS && MODULES
	depends on HAVE_KPROBES
	help
	  Kprobes allows you to trap at almost any kernel address and
	  execute a callback function.  register_kprobe() establishes
	  a probepoint and specifies the callback.  Kprobes is useful
	  for kernel debugging, non-intrusive instrumentation and testing.
	  If in doubt, say "N".

config HAVE_EFFICIENT_UNALIGNED_ACCESS
	bool
	help
	  Some architectures are unable to perform unaligned accesses
	  without the use of get_unaligned/put_unaligned. Others are
	  unable to perform such accesses efficiently (e.g. trap on
	  unaligned access and require fixing it up in the exception
	  handler.)

	  This symbol should be selected by an architecture if it can
	  perform unaligned accesses efficiently to allow different
	  code paths to be selected for these cases. Some network
	  drivers, for example, could opt to not fix up alignment
	  problems with received packets if doing so would not help
	  much.

	  See Documentation/unaligned-memory-access.txt for more
	  information on the topic of unaligned memory accesses.

config HAVE_SYSCALL_WRAPPERS
	bool

config KRETPROBES
	def_bool y
	depends on KPROBES && HAVE_KRETPROBES

config HAVE_IOREMAP_PROT
	bool

config HAVE_KPROBES
	bool

config HAVE_KRETPROBES
	bool

#
# An arch should select this if it provides all these things:
#
#	task_pt_regs()		in asm/processor.h or asm/ptrace.h
#	arch_has_single_step()	if there is hardware single-step support
#	arch_has_block_step()	if there is hardware block-step support
#	asm/syscall.h		supplying asm-generic/syscall.h interface
#	linux/regset.h		user_regset interfaces
#	CORE_DUMP_USE_REGSET	#define'd in linux/elf.h
#	TIF_SYSCALL_TRACE	calls tracehook_report_syscall_{entry,exit}
#	TIF_NOTIFY_RESUME	calls tracehook_notify_resume()
#	signal delivery		calls tracehook_signal_handler()
#
config HAVE_ARCH_TRACEHOOK
	bool

config HAVE_DMA_ATTRS
	bool

config USE_GENERIC_SMP_HELPERS
	bool

config HAVE_CLK
	bool
	help
	  The <linux/clk.h> calls support software clock gating and
	  thus are a key power management tool on many systems.

config HAVE_DMA_API_DEBUG
	bool

config HAVE_DEFAULT_NO_SPIN_MUTEXES
	bool

source "kernel/gcov/Kconfig"
